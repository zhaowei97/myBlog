`这个点应该算得上是面试中露头次数比较多的知识点了`
## 首先来个大体的概括
* 浏览器地址栏输入 URL 并回车
* 浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期
* DNS 解析 URL 对应的 IP
* 根据 IP 建立 TCP 连接（三次握手）
* 发送 http 请求
* 服务器处理请求，浏览器接受 HTTP 响应
* 浏览器解析并渲染页面
* 关闭 TCP 连接（四次握手）

## DNS解析
> DNS解析其实就是一个寻找目标资源的过程,比如我们在浏览器输入`www.xxx.com`,但其实这个网址并不是其实际资源所对应的地址，因为在互联网中每一台电脑其实都有一个唯一的标识----IP地址,这个才是关键，由于不方便记忆，所以就需要一个网址和IP之间的转换，也就是我们所说的DNS解析。

### 具体解析
输入`www.xxx.com`网址后,首先在本地的域名服务器中查找,没找到的话去根域名服务器查找,没有的话去根域名服务器查找,再没有的话去com顶级域名服务器查找...如此类推下去,直到找到对应的IP地址，然后记录在本地，供下次使用。大致过程就是.=>.com=>xxx.com=>www.xxx.com。（.代表的是根域名服务器，只是默认情况下会省略）

### DNS优化
> 如上所示，dns解析的过程其实经历了很多次，所以会产生一定的消耗和时间等待，下面就开始从这一块着手
#### DNS缓存
DNS存在着多级缓存，从距离开始排序的话大致就是：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存（也就是我们的供应商），根域名那服务器缓存，顶级域名服务器缓存，主域名服务器缓存。

#### DNS负载均衡
每次访问某个网址时候，响应的并非是同一个服务器（IP地址不同），毕竟如果只是一个服务器，当有大量的访问时候，除非是特别牛的性能和存储量才能扛下来，不然基本gg。所以DNS就会返回一个合适的机器IP给用户（依据机器负载量和用户到机器的距离），这种就是DNS的负载均衡。

## 发起TCP连接
> TCP提供一种可靠的传输，过程涉及到三次握手，四次挥手
### 三次握手
* 第一次握手
客户端发送syn包到服务器，并进行SYN_SEND状态，等待服务器确认
* 第二次握手
服务端收到syn包，同时自己也发送一个SYN+ACK包，此时服务器进入SYN_RECV状态
* 第三次握手
客户端收到服务器的SYN+ACK包，向服务器发送确认ACK包，客户端和服务器都进入ESTABLISHED状态，完成三次握手

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/9/d8bf92c7906718271fdb8b0d2d5fe5b4~tplv-t2oaga2asx-watermark.awebp)

> 握手过程中传送的包不包含数据，只有等握手完毕后才开始正式传输数据。理想状态下，TCP一旦建立连接，除非通信双方的任何一方主动关闭连接，否则会一直保持下去。

### 为什么是三次握手而不是两次，四次？
采用三次握手是为了防止失效的连接报文突然又传回到服务端而产生错误。`失效的连接就是指客户端发出的请求没有收到服务端的确认，从而过了一段后又重新向服务端发送确认请求，且建立成功，完成数据传输。但如果说第一次发出的请求其实并没有丢失，只是因为网络延迟晚点才到达服务端，于是又向客户端发回确认，但此时客户端根本不会理会，所以服务端就会一直等服务端发送数据，导致服务端资源浪费`。
为啥两次握手不行，就是上面所说的这个原因了。如果说服务端收到客户端因为网络延迟而晚到的连接请求，那么直接返回确认并建立连接，就会造成资源浪费了。
至于为啥不是四次，总而言之就是增加一次并不能显著提高可靠性。

### 四次挥手
#### 第一次挥手
客户端发送FIN，用来告诉服务端之后将不再发送数据（当然，在FIN包之前发送的数据，如果没有收到服务端返回的ack确认报文，客户端依旧会重发这些数据），但是此时的客户端还是可以接收数据的。FIN=1,序列号为seq=u（等于前面传送过来的数据的最后一个字节的序号加一），此时客户端进入FIN-WAIT-1状态。

#### 第二次挥手
服务器收到FIN包后，发送一个ACK给对方并且带上自己的序列号seq，确认序号为收到序号+1。此时，服务端进入CLOSE-WAIT（关闭等待）状态。这个期间还要持续一段时间，在这期间，客户端已经没有数据要发送了，但是如果服务端要发送数据给客户端，客户端仍然要接受。
此时的客户端就进入了FIN-WAIT-2状态，等待服务器发送连接释放报文。
#### 第三次挥手
服务器发送一个FIN，用来关闭服务器到客户端的数据传送，也就是告诉客户端，这边的数据发送完了。由于之前是半关闭状态，所以序号可能不同了。此时服务器进入LAST-ACK状态，等待客户端确认。
#### 第四次挥手
客户端收到FIN后，发送一个ACK给服务端，确认序号为收到序号+1,此时客户端进入TIME-WAIT状态。经过最长保温的两倍时长后进入CLOSED状态。
而服务端只要收到客户端的确认，就会立即进入CLOSED状态。所以可以看出服务端结束TCP连接的时间比客户端早一些。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/9/8c7874fafe233c9278509e40e906055c~tplv-t2oaga2asx-watermark.awebp)

#### 为什么客户端最后会等待2MSL（MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值）?
为了保证客户端最后传给服务端的ACK报文在丢失情况下能够接受到服务端重新发回来的FIN，然后客户端重传确认报文，重新启动时间等待计时器，否则的话，服务端将无法正常关闭连接。

#### 为什么建立连接是三次握手，关闭连接确是四次挥手呢？

> 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。


## 发送HTTP请求
> 将我们的构建的HTTP请求报文通过TCP协议发送到服务端指定端口（http的端口为80，https为443）
### POST和GET的区别
* GET请求会被浏览器缓存，但是POST不会，除非手动设置
* GET参数通过url传递，POST放在请求正文body中
* GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息
* GET请求在URL中传送的参数是有长度限制的，而POST没有
...


待补充