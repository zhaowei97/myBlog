# 数组的浅拷贝

> 针对基本类型的元素，可以通过数组的特性方法进行浅拷贝，比如slice，concat。

# 数组的深拷贝

最常规的就是使用JSON.stringify和JSON.parse组合使用实现深拷贝。不过有个问题，就是对于函数类型的拷贝会出现丢失的问题。

```
var arr = [function(){
    console.log(a)
}, 1]

var new_arr = JSON.parse(JSON.stringify(arr));

console.log(new_arr);  // 数组的第一位会出现丢失情况
```

# 浅拷贝的实现
```
var shallowCopy = function(obj) {
    // 只拷贝对象
    if (typeof obj !== 'object') return;
    // 根据obj的类型判断是新建一个数组还是对象
    var newObj = obj instanceof Array ? [] : {};
    // 遍历obj，并且判断是obj的属性才拷贝
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = obj[key];
        }
    }
    return newObj;
}
```

# 深拷贝实现
> 跟浅拷贝的区别点在于--当某个值对应的是引用类型时，采用递归形式重新调用拷贝方法。
```
var deepCopy = function(obj) {
    if (typeof obj !== 'object') return;
    var newObj = obj instanceof Array ? [] : {};
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key];
        }
    }
    return newObj;
}
```

> 循环引用问题解决
```
const map = new Map(); // 记录所有对象的关系
var deepCopy = function(obj) {
    if (typeof obj !== 'object') return;
    //如果这个对象已经被记录则直接返回
    if(map.get(obj)){
      return map.get(obj)
    }
    var newObj = obj instanceof Array ? [] : {};
    map.set(obj, newObj)
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key];
        }
    }
    return newObj;
}
```

