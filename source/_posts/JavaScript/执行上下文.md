> 执行上下文是执行JavaScript代码环境的抽象概念。

## 执行上下文类型

* **全局执行上下文**——默认或者基础上下文，任何不在函数中的代码都在全局上下文中。他会执行两件事：创建一个全局window对象（浏览器情况下），设置this等于这个全局window对象。一个程序中只会有一个全局执行上下文。
* **函数执行上下文**——函数调用时才会创建函数执行上下文，且函数执行上下文可以有任意多个。每一个新的函数执行上下文被创建，都会按定义的顺序执行一系列操作。
* **Eval执行上下文**——用的少，不讨论。

## 执行栈
> 执行栈也就是我们编程语言中常说的调用栈，具有LIFO（后进先出）的数据结构，用来存储代码运行时所创建的所有执行上下文。

当JavaScript引擎第一次遇到脚本时，他会创建一个全局执行上下文并压入当前执行栈。每遇到一个函数调用，它会为该函数创建一个函数执行上下文压入栈顶。

引擎会执行位于栈顶的函数。当函数执行结束，执行上下文从栈中弹出，并进入下一个流程。

## 如何创建执行上下文
> 创建执行上下文分为两个阶段： **创建阶段**和**执行阶段**

### 创建阶段
* **this的绑定**——全局上下文中指全局对象（浏览器中引用window对象）。在函数执行上下文中，this的值取决于该函数如何被调用。如果是被一个引用对象调用，那么this就是调用的对象，否则便会被设置为全局对象或者undefined（严格模式下）。例如：
```
  let foo = {
  baz: function() {
    console.log(this);
    }
  }
  foo.baz();   // 'this' 引用 'foo', 因为     'baz' 被
               // 对象 'foo' 调用
  let bar = foo.baz;
  bar();       // 'this' 指向全局 window 对象，因为
               // 没有指定引用对象
```
  
* **词法环境**——简单来说词法环境是一种持有**标识符——变量映射**的结构。（标识符是指变量/函数的名称，而变量映射是对实际对象或者原始数据的引用）。
  ##### 在词法环境的内部有两个组件：
  * 环境记录器：存储变量和函数声明的实际位置
  * 外部环境的引用：意味着可以访问父级词法环境（作用域）
  ##### **词法环境**有两种类型：
  * **全局环境**的外部环境引用是**null**，它拥有内建的Object/Array等，还有任何用户自定义的全局变量。
  * **函数环境**中，函数内部定义的变量存储在**环境记录器**中。并且引用的外部环境可能是全局环境，也有可能是内部函数的外部函数。
  ##### 环境记录器也有两种类型（如上）
  * **声明式环境记录器**存储变量、函数和参数（函数环境中）
  * **对象环境记录器**用来定义出现在全局上下文中的变量和函数的关系（全局环境中）
* **变量环境**
  > 同样是一个词法环境（拥有词法环境的所有属性），其环境记录器持有**变量声明语句**在执行上下文中创建的绑定关系。在 ES6 中，词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定。

  > 这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 undefined（var 情况下），或者未初始化（let 和 const 情况下）。
  这就是为什么你可以在声明之前访问 var 定义的变量（虽然是 undefined），但是在声明之前访问 let 和 const 的变量会得到一个引用错误。
   这就是我们说的变量声明提升。


### 执行阶段

> 在此阶段，完成对所有变量的分配，最后执行代码

**注意**——在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 let 变量的值，它会被赋值为 undefined。
