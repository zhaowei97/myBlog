# 函数组件
## 注意点：
* 函数组件接受一个单一的props对象并返回一个React元素
* 组件名必须大写开头
* 组件返回值只能有一个根元素
* 组件返回值不一定得是DOM元素，也可以是其他的自定义组件

```
// react.js
// 1.多加一层判断，函数组件的JSX结构中type属性是一个函数。
if (typeof type === "function") {
    dom = mountFunctionComponent(vdom);
}
// 2. 渲染函数组件
function mountFunctionComponent(vdom) {
  const { type, props } = vdom;
  const renderVdom = type(props);
  return createDOM(renderVdom);
}
```

> 核心还是基于之前我们的初版react-dom进行改造。从上述代码看的话其实很简单，类似于我们常规的函数执行，最终返回一个虚拟DOM结构，最后调用我们前期文章中就定义好了的方法创建真实节点。而至于我们为什么在函数组件上添加的属性到了props中就变成了一个对象，这些都是babel为我们做的，就不深入研究了。

# 类组件

跟函数组件不同的是，类组件的写法需要继承React.Component，所以需要在react.js中多返回一个Component属性
```
// constants.js
const REACT_COMPONENT = Symbol("react.component");

// Component.js
import { REACT_COMPONENT } from "./constants";

export class Component {
  static isReactComponent = REACT_COMPONENT;
  constructor(props) {
    this.props = props;
  }
}

// react.js
import { Component } from "./Component";

...

const React = {
  createElement,
  Component,
};

export default React;


```

> 这里需要注意下类中有定义一个静态属性isReactComponent，且必须是唯一，后续会解释



然后就是react-dom中的改造：由于类组件被babel转义后实际上也是一个函数类型，所以需要基于上面函数组件的判断多加一层
```
// react-dom.js
if (typeof type === "function") {
    if (type.isReactComponent) {
      dom = mountClassComponent(vdom);
    } else {
      dom = mountFunctionComponent(vdom);
    }
}

...

function mountClassComponent(vdom) {
  const { type, props } = vdom;
  const domInstance = new type(props);
  const renderVdom = domInstance.render();
  return createDOM(renderVdom);
}
```

> 从这里可以看出，之所以在Component类中加上唯一的静态属性就是为了区分函数组件和类组件，且定义为Symbol类型防止篡改判断属性。最后转换为真实DOM时，跟函数不同的是这里需要实例化后通过实例调用render属性方法拿到返回的虚拟DOM结构，至于为什么，写过类组件的应该都懂的。