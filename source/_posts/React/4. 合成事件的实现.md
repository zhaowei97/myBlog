# 合成事件的实现

关于事件使用的一些注意点：

* React 事件的命名采用小驼峰式(camelCase),而不是纯小写
* 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串
* 你不能通过返回 false 的方式阻止默认行为。你必须显式的使用preventDefault

针对以上，我们来进行其基本流程的实现

```
// react-dom.js
function updateProps(dom, oldProps = {}, newProps = {}) {
  // 添加新属性
  for (const key in newProps) {
    if (key === "children") {
      continue;
    } else if (key === "style") {
      const styleObj = newProps[key];
      for (const attr in styleObj) {
        dom.style[attr] = styleObj[attr];
      }
    } else if (/^on[A-Z].*/.test(key)) {
      addEvent(dom, key.toLowerCase(), newProps[key]);    //  主要看这行  自定义事件函数
    } else {
      dom[key] = newProps[key];
    }
  }
  //   删除老属性
  for (const key in oldProps) {
    if (!Object.hasOwnProperty.call(newProps, key)) {
      delete dom[key];
    }
  }
}


// event.js

import { updateQueue } from "./Component";

/**
 * 给DOM元素绑定合成事件 在合成事件处理函数中调用我们自己写的处理函数
 * @param {*} dom 真实DOM
 * @param {*} eventType  事件类型 click
 * @param {*} handle   用户自定义的处理函数
 */
export function addEvent(dom, eventType, handler) {
  let store = dom._store_ || (dom._store_ = {}); // 这个属性是我们自定义命名的 主要就是作为存储属性使用
  // store.click = handler
  store[eventType] = handler;
  if (!document[eventType]) {
    document[eventType] = dispatchEvent;
  }
  /**
   * 委托给文档对象的处理函数
   * @param {*} event 原生的事件对象
   */
  function dispatchEvent(event) {
    // 事件名称 click 和 事件源
    const { type, target } = event;
    const eventType = `on${type}`;
    updateQueue.isBatchingUpdate = true;
    let syntheticEvent = createSyntheticEvent(event);
    // 模拟事件冒泡
    let currentTarget = target;
    while (currentTarget) {
      syntheticEvent.currentTarget = currentTarget;
      const { _store_ } = currentTarget;
      let handler = _store_ && _store_[eventType];
      handler && handler(syntheticEvent);
      if (syntheticEvent.isPropagationStopped) break;
      currentTarget = currentTarget.parentNode;
    }
    updateQueue.batchUpdate();
  }

  function createSyntheticEvent(nativeEvent) {
    let syntheticEvent = {};
    for (const key in nativeEvent) {
      let value = nativeEvent[key];
      if (typeof value === "function") value = value.bind(nativeEvent);
      syntheticEvent[key] = value;
    }
    syntheticEvent.nativeEvent = nativeEvent;
    syntheticEvent.isPropagationStopped = false; // 是否阻止了冒泡
    syntheticEvent.isDefaultPrevent = false; // 是否阻止了默认事件
    syntheticEvent.stopPropagation = stopPropagation;
    syntheticEvent.preventDefault = preventDefault;
    return syntheticEvent;
  }

  function preventDefault() {
    this.isDefaultPrevent = true;
    let event = this.nativeEvent;
    if (event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnValue = false;
    }
  }

  function stopPropagation() {
    this.isPropagationStopped = true;
    let event = this.nativeEvent;
    if (event.stopPropagation) {
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
  }
}

```

总结一下以上的代码：可以看到我们在给DOM绑定on事件时，会在props属性更新阶段对其进行处理，并且将setState的批量更新开关放置了其中，这样就不需要我们每次都在绑定事件的回调函数中进行开启了。由于React的事件并不是绑定对应点击的DOM上的，统一委托document进行处理，所以我们定义一个函数进行委托处理，在其中我们还需要考虑事件的冒泡，所以就需要一个递归来不断更新冒泡时当前所在的节点，并且还需要考虑点击事件的回调函数中是否存在阻止冒泡或者组织默认事件的函数调用，这里的话就按照React的标准写了俩个兼容性的函数，满足多平台使用。


> 需要注意的是： 比如说点击事件，在document对象中我们只会添加一次属性（从  if (!document[eventType])  可以看出），后续则是根据对应dom上我们添加的_store_存储属性去拿对应的回调函数进行执行。